#!/bin/sh

# Set this with a string describing the validation error(s) if any occur
export validate_error=

# See https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux
RED='\033[0;31m'
NC='\033[0m' # No Color

add_validate_error() {
	validate_error="${validate_error}:$1"
	export validate_error
	printf "${RED}Validation Error:$1${NC}\n"
}


# This function is used to ssh into qemu in order to execute a command fed as parameter
# @parameter1: command to be executed inside qemu
ssh_cmd() {
	cmd=$1 
	sshpass -p 'root' ssh -o StrictHostKeyChecking=no root@localhost -p 10022 ${cmd}
}


# This function waits for the qemu to boot up.
wait_for_qemu(){
	echo "Waiting 30s for qemu to startup"
	sleep 30s
}


# This function runs runqemu.sh in background and waits for qemu to boot up.
validate_qemu(){
	echo "Executing runqemu.sh in background"
	
	# See https://stackoverflow.com/a/32569573 
	# Removing unnecessary prints due to runqemu.sh and displays prints as soon as it encounters "Starting network: IPv6: ADDRCONF(NETDEV"
	./runqemu.sh | sed -e '1,/Starting network: IPv6: ADDRCONF(NETDEV/ d' &
#	./runqemu.sh &
	wait_for_qemu
}

# This function copies the testing scripts inside qemu and executes them.
# @parameter1: Absolute Directory path to the testing scripts on the host machine in order to copy them inside qemu.
# @parameter2: Absolute Directory path where the testing scripts need to be copied inside qemu.
# Note: The testing scripts should be copied in the same directory where the executables are stored.
validate_assignment2_checks() {
	script_dir=${1}
	executable_path=${2}

	# scp the scripts required to validate the assignment 1 checks.
	sshpass -p 'root' scp -o StrictHostKeyChecking=no -P 10022 ${script_dir}/assignment-1-test.sh root@localhost:${executable_path}
	sshpass -p 'root' scp -o StrictHostKeyChecking=no -P 10022 ${script_dir}/assignment-1-test-iteration.sh root@localhost:${executable_path}
	sshpass -p 'root' scp -o StrictHostKeyChecking=no -P 10022 ${script_dir}/script-helpers root@localhost:${executable_path}
	
	ssh_cmd "${executable_path}/assignment-1-test.sh"
	rc=$?
	if [ $rc -ne 0 ]; then
		add_validate_error "Failed to run assignment-1-test script inside qemu"
	fi
}


# This function is used for validating buildroot defconfig file in base_external/configs/aesd_qemu_defconfig file.
validate_buildroot_config() {
	DEFCONFIG_BASE_EXTERNAL=base_external/configs/aesd_qemu_defconfig

	grep -q 'BR2_PACKAGE_DROPBEAR=y' "${DEFCONFIG_BASE_EXTERNAL}"
	rc=$?
	if [ $rc -ne 0 ]; then
		add_validate_error "Dropbear support missing in aesd_qemu_defconfig"
		echo "Adding Dropbear Support manually"
		echo 'BR2_PACKAGE_DROPBEAR=y' >> "${DEFCONFIG_BASE_EXTERNAL}"
	fi
	
	grep -q 'BR2_PACKAGE_AESD_ASSIGNMENTS=y' "${DEFCONFIG_BASE_EXTERNAL}"
	rc=$?
	if [ $rc -ne 0 ]; then
		add_validate_error "AESD_ASSIGNMENTS package disabled in aesd_qemu_defconfig"
		echo "Adding AESD_ASSIGNMENTS package manually"
		echo 'BR2_PACKAGE_AESD_ASSIGNMENTS=y' >> "${DEFCONFIG_BASE_EXTERNAL}"
	fi
	
	grep -q 'BR2_TARGET_GENERIC_ROOT_PASSWD="root"' "${DEFCONFIG_BASE_EXTERNAL}"
	rc=$?	
	if [ $rc -ne 0 ]; then
		add_validate_error "Root password not added in aesd_qemu_defconfig"
		echo "Setting password to root manually"
		echo 'BR2_TARGET_GENERIC_ROOT_PASSWD="root"' >> "${DEFCONFIG_BASE_EXTERNAL}"	
	fi
}


# This function checks for Wall and Werror flags in makefile
validate_makefile_flags() {
	echo "validating makefile Flags"

	commit_id=$(grep "AESD_ASSIGNMENTS_VERSION" base_external/package/aesd-assignments/aesd-assignments.mk | cut -d "=" -f2 | tr -d ' ')
	MAKEFILE_PATH=buildroot/output/build/aesd-assignments-${commit_id}


	grep -is "wall" ${MAKEFILE_PATH}/makefile
	rc=$?
	if [ $rc -ne 0 ]; then
		grep -is "wall" ${MAKEFILE_PATH}/Makefile
		rc=$?
		if [ $rc -ne 0 ]; then
			add_validate_error "wall flag missing in Makefile"
		fi
	fi

	grep -is "Werror" ${MAKEFILE_PATH}/makefile
	rc=$?
	if [ $rc -ne 0 ]; then
		grep -is "Werror" ${MAKEFILE_PATH}/Makefile
		rc=$?
		if [ $rc -ne 0 ]; then
			add_validate_error "Werror flag missing"
		fi
	fi
}


# This function copies the required file to the directory ~/assignment4_build_binaries/<basename ${1}>
# @parameter1: This parameter is the path to the root directory of the github repository.
save_build_binaries() {
	docker_buildroot_shared_dir=/var/aesd/buildroot-shared	
	student_folder=$(basename ${1})
	student_folder_path=${docker_buildroot_shared_dir}/students_build_binaries/${student_folder}
	mkdir -p ${student_folder_path}
	echo "Directory consisting of build binaries at ${student_folder_path} created"
	cp buildroot/output/images/Image ${student_folder_path}
       	cp buildroot/output/images/rootfs.ext4 ${student_folder_path}	
}


# THIS FUNCTION IS NO LONGER REQUIRED
# This function fetches the output file from qemu to the host machine
fetch_output_file() {
#	for i in $( seq 1 20)
#	do
		ssh_cmd "tester.sh"
		rc=$?
		if [ $rc -eq 0 ]; then
			sshpass -p 'root' scp -P 10022 root@localhost:~/assignments/assignment4/assignment-4-result.txt test_result
			rc=$?			
			if [ $rc -ne 0 ]; then
				sshpass -p 'root' scp -P 10022 root@localhost:/root/assignment-4-result.txt test_result 
				rc=$?				
				if [ $rc -ne 0 ]; then
					add_validate_error "Failed to SCP assignment-4-result.txt from remote !!!"
				fi
			else
				add_validate_error "assignment-4-result.txt found but not located at ~/ Dir"
			fi
			
			sshpass -p 'root' scp -P 10022 root@localhost:/tmp/ecen5013/ECEN_5013_IS_AWESOME10 test_result 
			rc=$?
			if [ $rc -ne 0 ]; then
				sshpass -p 'root' scp -P 10022 root@localhost:/tmp/aesd-data/AESD_IS_AWESOME10 test_result
				rc=$?				
				if [ $rc -ne 0 ]; then 
					add_validate_error "Failed to SCP ECEN_5013_IS_AWESOME10 from remote !!!"
				fi
			fi
			
			break;
		fi
		
#		if [ $i -eq 20 ]; then
#			add_validate_error "Failed to SSH in QEMU !!!"
#		fi
#		sleep 5s
#	done
}


# THIS FUNCTION IS NO LONGER REQUIRED
# This function validates the output file.
validate_output_file() {
	fetch_output_file

	cat test_result/assignment-4-result.txt | grep "The number of files are 10 and the number of matching lines are 10"
	rc=$?	
	if [ $rc -ne 0 ]; then
		add_validate_error "Text in assignment4-result.txt file not as expected !!!"
	fi
	
	cat test_result/ECEN_5013_IS_AWESOME10 | grep "${githubstudent}"
	rc=$?
	if [ $rc -ne 0 ]; then
		cat test_result/AESD_IS_AWESOME10 | grep "${githubstudent}"
		rc=$?
		if [ $rc -ne 0 ]; then
			add_validate_error "Expected Github Usename: ${githubstudent} but found no match"
		fi
	fi
	
	cat test_result/ECEN_5013_IS_AWESOME10 | grep "1970"
	rc=$?
	if [ $rc -ne 0 ]; then
		cat test_result/AESD_IS_AWESOME10 | grep "${githubstudent}"
		rc=$?
		if [ $rc -ne 0 ]; then
			add_validate_error "Expected EPOCH time but found no match !!!"
		fi
	fi
}

# See logic used for gitlab runners in https://docs.gitlab.com/ee/ci/ssh_keys/#ssh-keys-when-using-the-docker-executor
# We will use this logic in a before_script execution so we can use the same strategy
# inside or outside a docker container
before_script() {
	##
	## Install ssh-agent if not already installed, it is required by Docker.
	## (change apt-get to yum if you use an RPM-based image)
	##
	which ssh-agent || ( apt-get update -y && apt-get install openssh-client -y )

	##
	## Run ssh-agent (inside the build environment)
	##
	eval $(ssh-agent -s)
	
	
	if [ -n "${SSH_PRIVATE_KEY_BASE64}" ]; then
		# See https://serverfault.com/a/978369
		# Use this to support gitlab CI requirements for environment variable masking
		echo "Converting base64 key"
		SSH_PRIVATE_KEY=`echo ${SSH_PRIVATE_KEY_BASE64} | openssl base64 -A -d`
		SSH_PRIVATE_KEY_BASE64=
	fi

    if [ -z "${SSH_PRIVATE_KEY}" ]; then
        echo "Private key is not set, attempts to clone will fail"
    else
        echo "Setting private key"
        set -e
        ##
        ## Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store
        ## We're using tr to fix line endings which makes ed25519 keys work
        ## without extra base64 encoding.
        ## https://gitlab.com/gitlab-examples/ssh-private-key/issues/1#note_48526556
        ##
        echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
        set +e
        # Now that we don't need the private key anymore zero it out
        export SSH_PRIVATE_KEY=
    fi

    echo "Running as:"
    echo `whoami`
	##
	## Create the SSH directory and give it the right permissions
	##
	mkdir -p ~/.ssh
	chmod 775 ~/.ssh

	##
	## Optionally, if you will be using any Git commands, set the user name and
	## and email.
	##

	touch ~/.ssh/known_hosts
	ssh-keyscan github.com >> ~/.ssh/known_hosts
	#- git config --global user.email "user@example.com"
	#- git config --global user.name "User name"
}


# Validate the assignment 5 implementation against a running qemu instance
# This means making sure we can run sockettest.sh against qemu after startup
validate_assignment5_qemu() {
	script_dir=${1}
    pushd ${script_dir}
    ./sockettest.sh
    rc=$?
    if [ $rc -ne 0 ]; then
        add_validate_error "sockettest.sh returned $rc attempting to run against qemu instance"
    fi
    popd
}

# Validate the assignment 5 implementation against native code
# This means compiling natively, then starting aesdsocket as daemon, then
# running sockettest.sh against the running instance
# Arguments: 1) The script directory containing the sockettest executable
#            2) The source directory containing the aesdsocket application source code and makefile
validate_assignment5_native() {
	script_dir=${1}
    source_dir=${2}
    pushd ${source_dir}
    make clean && make
    rc=$?
    if [ $rc -ne 0 ]; then
        add_validate_error "make returned $rc attempting to build native application"
    fi
    ./aesdsocket -d
    rc=$?
    if [ $rc -ne 0 ]; then
        add_validate_error "starting aesdocket failed with $rc"
    fi
    pushd ${script_dir}
    ./sockettest.sh
    rc=$?
    if [ $rc -ne 0 ]; then
        add_validate_error "sockettest.sh returned $rc attempting to run against native compiled aesdsocket instance"
    fi
    pkill aesdsocket
    popd
    popd
}
