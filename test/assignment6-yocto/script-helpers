#!/bin/bash

# Set this with a string describing the validation error(s) if any occur
validate_error=

# See https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux
RED='\033[0;31m'
NC='\033[0m' # No Color

add_validate_error() {
	validate_error="${validate_error}:$1"
	export validate_error
	printf "${RED}Validation Error:$1${NC}\n"
}


#This function is used to ssh into qemu in order to execute a command fed as parameter
#@parameter1: command to be executed inside qemu
ssh_cmd() {
	cmd=$1 
	#sshpass -p 'root' ssh -o StrictHostKeyChecking=no root@10.0.2.15 ${cmd}
	sshpass -p 'root' ssh -o StrictHostKeyChecking=no root@localhost -p 10022 ${cmd}

}


# This function waits for the qemu to boot up.
wait_for_qemu() {
	echo "Waiting 60s for qemu to startup"
	sleep 60s
}


# This function runs runqemu.sh in background and waits for qemu to boot up.
validate_qemu() {
	echo "Executing runqemu.sh in background"
	./runqemu.sh | sed -e '1,/Starting network: IPv6: ADDRCONF(NETDEV/ d' &
	wait_for_qemu
}


# This function runs sockettest.sh in order to validate aesdsocket functionality.
# @param1: Path to sockettest.sh script
validate_socket() {
	script_dir=$1
	echo "Running sockettest.sh"

	${script_dir}/sockettest.sh -t localhost
	rc=$?
	if [ $rc -ne 0 ]; then
		add_validate_error "sockettest.sh failed for required testcases inside qemu"
	fi
}


# This function runs sockettest_long_string.sh in order to validate aesdsocket functionality for long strings.
# @param1: Path to sockettest_long_string.sh script
validate_socket_long_string() {
	script_dir=$1
	echo "Running sockettest_long_string.sh"
	pushd ${script_dir}
	./sockettest_long_string.sh -t localhost
	rc=$?
	if [ $rc -ne 0 ]; then
		add_validate_error "sockettest_long_string.sh failed for long string inside qemu"
	fi
	popd
}


# This function validates whether aesdsocket runs as a daemon at startup.
# If the aesdsocket does not run at boot up, aesdsocket is run as daemon manually.
validate_socket_daemon() {
	echo "validating aesdsocket daemon task"

	ssh_cmd "ps | grep -v grep| grep /usr/bin/aesdsocket"
	rc=$?
	if [ $rc -ne 0 ]; then
		add_validate_error "aesdsocket does not run as daemon on startup"
		echo "Running aesdsocket as daemon manually"
		ssh_cmd "/usr/bin/aesdsocket -d" &
		sleep 5s
	fi
	sleep 5s
}


# This function validates if the /var/tmp/aesdsocketdata or /var/tmp/aesdsocketdata.txt file has been deleted.
validate_aesdsocketdata_removal() {
	echo "Validating if the file /var/tmp/aesdsocketdata has been deleted"
	if [ -e /var/tmp/aesdsocketdata ] || [ -e /var/tmp/aesdsocketdata.txt ]; then
		add_validate_error "/var/tmp/aesdsocketdata has not been deleted at the end"
		echo "Deleting /var/tmp/aesdsocketdata or /var/tmp/aesdsocketdata.txt"
		rm /var/tmp/aesdsocketdata || rm /var/tmp/aesdsocketdata.txt
	fi
}


# This function validates if the aesdsocket program has implemented a signal handler catching signals SIGTERM and SIGINT
# The aesdsocket program must be running before calling this functions 
validate_signal_handlers() {
	echo "validating signal handlers for SIGTERM and SIGINT"

	ssh_cmd 'kill -s 15 $(pidof aesdsocket)'
	ssh_cmd "ps | grep -v grep| grep /usr/bin/aesdsocket"
	rc=$?
	if [ $rc -ne 0 ]; then
		echo "successfully killed using SIGTERM"

		#validating if the textfile has been deleted at the end
		validate_aesdsocketdata_removal
	else
		add_validate_error "Signal handler for SIGTERM cannot terminate aesdsocket"
	fi

	# Running the program again
	echo "Running aesdsocket program again"
	# The below command does not work unless run in background. Can't seem to understand why.
	ssh_cmd "/usr/bin/aesdsocket -d" &		
	rc=$?

	sleep 5s

	if [ $rc -eq 0 ]; then
		echo "aesdsocket running"
		ssh_cmd 'kill -s 2 $(pidof /usr/bin/aesdsocket)'
		ssh_cmd "ps | grep -v grep| grep /usr/bin/aesdsocket"
		rc=$?
		if [ $rc -ne 0 ]; then
			echo "successfully killed using SIGINT"

			#validating if the textfile has been deleted at the end
			validate_aesdsocketdata_removal
		else
			add_validate_error "Signal handler for SIGINT cannot terminate aesdsocket"
		fi
	else
		add_validate_error "Could not find aesdsocket in /usr/bin"
	fi
}


## TODO: Recheck this function implementation
validate_error_checks() {
	echo "validating error codes"
		
	ssh_cmd "/usr/bin/aesdsocket -d" & 
	rc=$?
	if [ $rc -eq 0 ]; then
		sleep 5s

		## TODO Check this might get stuck if failed actually
		ssh_cmd "/usr/bin/aesdsocket -d" 
		rc=$?
		sleep 5s
		if [ $rc -ne 0 ]; then
			echo "-1 returned for bind error"
		else
			add_validate_error "bind error not handled"
		fi
	ssh_cmd 'kill -9 $(pidof aesdsocket)'
	fi
}


# This function creates the aesdsocket executable and checks for memory leaks using Valgrind.
# The function checks for memeory leaks on host machine after running sockettest.sh and killing it to cover all kinds of memory leaks.
# @param1: Path to sockettest.sh script
validate_makefile_and_memoryleak() {
	script_dir=$1
	valgrind_test=0			# 0 indicates true

	echo "Removing any previous valgrind test output file"
	rm valgrind-out.txt
	echo "validating memory leak using Valgrind"

	commit_id=$(grep "SRCREV" meta-aesd/recipes-aesd-assignments/aesd-assignments/aesd-assignments_git.bb | cut -d'"' -f2)
	short_commit_id=$(echo ${commit_id} | head -c 10)
	MAKEFILE_PATH=build/tmp/work/aarch64-poky-linux/aesd-assignments/1.0+gitAUTOINC+${short_commit_id}-r0/git/

	make clean -C ${MAKEFILE_PATH}
	make -C ${MAKEFILE_PATH} || make all -C ${MAKEFILE_PATH}
	rc=$?
	if [ $rc -ne 0 ]; then
		add_validate_error "Makefile cannot build an executable on host machine"
		add_validate_error "Valgrind test was not implemented on host machine"

		valgrind_test=1		# 1 indicates false
	fi

	if [ $valgrind_test -eq 0 ]; then
		PATH_EXEC=$(find ${MAKEFILE_PATH} -name "aesdsocket")
		valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out.txt ./${PATH_EXEC}&
		sleep 10s
		
		# Running sockettest script here to take care of all memory leaks possible
		echo "Running sockettest.sh for Valgrind test"
		#${script_dir}/sockettest.sh -t localhost
		echo "TEST1: testing memory leak string" | nc localhost 9000 -w 1
		echo "TEST2: testing memory leak string" | nc localhost 9000 -w 1
		echo "TEST3: testing memory leak string" | nc localhost 9000 -w 1
		echo "TEST4: testing memory leak string" | nc localhost 9000 -w 1
		echo "TEST5: testing memory leak string" | nc localhost 9000 -w 1


		rc=$?
		if [ $rc -ne 0 ]; then
			add_validate_error "sockettest.sh failed for required testcases on host machine for Valgrind test, could not complete memory leak check"
		fi

		sleep 2s
		ps -aux | grep -v grep | grep "aesdsocket"
		pid_num=$(pidof '/usr/bin/valgrind.bin')
		echo "$pid_num"
		kill -s 2 ${pid_num}
		sleep 5s

		grep -i "no leaks are possible" valgrind-out.txt
		rc=$?
		if [ $rc -eq 0 ]; then
			echo "All memory freed"
			rm valgrind-out.txt
		else
			add_validate_error "Memory leak detected using Valgrind"
		fi
	fi
}


# This function checks for Wall and Werror flags in makefile
validate_makefile_flags() {
	echo "validating makefile Flags"

	commit_id=$(grep "SRCREV" meta-aesd/recipes-aesd-assignments/aesd-assignments/aesd-assignments_git.bb | cut -d'"' -f2)
	short_commit_id=$(echo ${commit_id} | head -c 10)
	MAKEFILE_PATH=build/tmp/work/aarch64-poky-linux/aesd-assignments/1.0+gitAUTOINC+${short_commit_id}-r0/git


	grep -i "wall" ${MAKEFILE_PATH}/makefile
	rc=$?
	if [ $rc -ne 0 ]; then
		grep -i "wall" ${MAKEFILE_PATH}/Makefile
		rc=$?
		if [ $rc -ne 0 ]; then
			add_validate_error "wall flag missing in Makefile"
		fi
	fi

	grep -i "Werror" ${MAKEFILE_PATH}/makefile
	rc=$?
	if [ $rc -ne 0 ]; then
		grep -i "Werror" ${MAKEFILE_PATH}/Makefile
		rc=$?
		if [ $rc -ne 0 ]; then
			add_validate_error "Werror flag missing"
		fi
	fi
}

# No longer required. Taken care inside assignment-5-test.sh
validate_bash_sh() {
	ROOTFS_PATH=build/tmp/work/qemuarm64-poky-linux/core-image-aesd/1.0-r0/rootfs
	filename=${ROOTFS_PATH}/$1
	cat "${filename}" | grep "#!/bin/sh" 
	rc=$?
	if [ $rc -ne 0 ]; then
		add_validate_error "${filename} contains #!/bin/bash"
		echo "#!/bin/bash replaced by #!/bin/sh in ${filename}"	
		sed -i 's/bash/sh/' "${filename}"
	else
		echo "${filename} already consists of #!/bin/sh"
	fi
}

# No longer required. Taken care inside assignment-5-test.sh
validate_bb_install() {
	ROOTFS_PATH=build/tmp/work/qemuarm64-poky-linux/core-image-aesd/1.0-r0/rootfs

	if [ ! -e ${ROOTFS_PATH}/etc/init.d/aesdsocket-start-stop ]; then
		add_validate_error "aesdsocket-start-stop script not found in /etc/init.d"
	else
		# Check for bash_sh here
		validate_bash_sh /etc/init.d/S99aesdsocket
	fi

	if [ ! -e ${ROOTFS_PATH}/usr/bin/aesdsocket ]; then
		add_validate_error "aesdsocket executable not found in /usr/bin"
	else
		echo "aesdsocket executable already exists"
	fi
}

# Not required for yocto
validate_buildroot_config() {
	grep -q 'BR2_PACKAGE_DROPBEAR=y' "base_external/configs/aesd_qemu_defconfig"
	rc=$?
	if [ $rc -ne 0 ]; then
		echo 'BR2_PACKAGE_DROPBEAR=y' >> "base_external/configs/aesd_qemu_defconfig"
		add_validate_error "Dropbear support missing in config, added manually."
	fi
	
	grep -q 'BR2_PACKAGE_AESD_ASSIGNMENTS=y' "base_external/configs/aesd_qemu_defconfig"
	rc=$?
	if [ $rc -ne 0 ]; then
		echo 'BR2_PACKAGE_AESD_ASSIGNMENTS=y' >> "base_external/configs/aesd_qemu_defconfig"
		add_validate_error "AESD_ASSIGNMENTS package disabled, Enabled manually."
	fi
	
	grep -q 'BR2_TARGET_GENERIC_ROOT_PASSWD="root"' "base_external/configs/aesd_qemu_defconfig"
	rc=$?
	if [ $rc -ne 0 ]; then
		echo 'BR2_TARGET_GENERIC_ROOT_PASSWD="root"' >> "base_external/configs/aesd_qemu_defconfig"
		add_validate_error "Root password added manually."
	fi
}
